#pragma kernel EncodeDepthToHue

// Input textures
Texture2D<float> _Depth;
Texture2D<float> _Stencil;
RWTexture2D<float4> _HueDepthRT;

// Settings: x=minDepth, y=maxDepth, z=stencilThreshold
float4 _DepthRange;
int _UseStencil;

// Metavido depth hue encoding constants (from Common.hlsl)
static const float mtvd_DepthHueMargin = 0.01;
static const float mtvd_DepthHuePadding = 0.01;

// Convert hue [0,1] to RGB (Metavido pattern)
float3 Hue2RGB(float hue)
{
    float h = hue * 6 - 2;
    float r = abs(h - 1) - 1;
    float g = 2 - abs(h);
    float b = 2 - abs(h - 2);
    return saturate(float3(r, g, b));
}

// Encode depth to RGB hue (matches mtvd_EncodeDepth exactly)
float3 EncodeDepth(float depth, float2 range)
{
    // Normalize to [0,1] based on depth range
    depth = (depth - range.x) / (range.y - range.x);

    // Apply padding
    depth = depth * (1 - mtvd_DepthHuePadding * 2) + mtvd_DepthHuePadding;

    // Apply margin
    depth = saturate(depth) * (1 - mtvd_DepthHueMargin * 2) + mtvd_DepthHueMargin;

    // Convert to RGB hue
    return Hue2RGB(depth);
}

[numthreads(32,32,1)]
void EncodeDepthToHue(uint3 id : SV_DispatchThreadID)
{
    // Get output dimensions
    float width, height;
    _HueDepthRT.GetDimensions(width, height);

    // Bounds check
    if (id.x >= (uint)width || id.y >= (uint)height)
        return;

    // Calculate UV coordinates
    float2 uv = float2(float(id.x) / width, float(id.y) / height);

    // Get depth texture dimensions
    float depthW, depthH;
    _Depth.GetDimensions(depthW, depthH);

    // Sample depth with Y-flip for ARKit texture origin
    uint2 depthCoord = uint2(uv.x * depthW, (1.0 - uv.y) * depthH);
    float depth = _Depth[depthCoord];

    // Stencil filtering (human-only when enabled)
    float stencilValue = 1.0;
    if (_UseStencil != 0)
    {
        float stencilW, stencilH;
        _Stencil.GetDimensions(stencilW, stencilH);
        uint2 stencilCoord = uint2(uv.x * stencilW, (1.0 - uv.y) * stencilH);
        stencilValue = _Stencil[stencilCoord];

        float stencilThreshold = _DepthRange.z > 0 ? _DepthRange.z : 0.5;
        if (stencilValue < stencilThreshold)
        {
            // Background pixel - encode as max depth (will appear as background in VFX)
            _HueDepthRT[id.xy] = float4(0, 0, 0, 0);
            return;
        }
    }

    // Depth range check
    float minDepth = _DepthRange.x;
    float maxDepth = _DepthRange.y;
    if (depth < minDepth || depth > maxDepth || depth <= 0)
    {
        // Invalid depth - encode as black (background)
        _HueDepthRT[id.xy] = float4(0, 0, 0, 0);
        return;
    }

    // Encode depth to RGB hue (Metavido format)
    float3 hueColor = EncodeDepth(depth, float2(minDepth, maxDepth));

    // Write hue-encoded depth with alpha = 1 for valid pixels
    _HueDepthRT[id.xy] = float4(hueColor, 1.0);
}
