#pragma kernel DepthToWorld
#pragma kernel CalculateVelocity

// Input textures
Texture2D<float> _Depth;
Texture2D<float> _Stencil;
RWTexture2D<float4> _PositionRT;

// Velocity calculation
Texture2D<float4> _PreviousPositionRT;
RWTexture2D<float4> _VelocityRT;
float _DeltaTime;

// Matrices
float4x4 _InvVP;
float4x4 _ProjectionMatrix;

// Settings: x=minDepth, y=maxDepth, z=stencilThreshold
float4 _DepthRange;
int _UseStencil;
int _RotateUV90CW;  // ARKit depth orientation fix

// Convert viewport position (UV + depth) to world position
// Matches GeneratePositionTexture.compute pattern exactly
float3 ViewportToWorldPoint(float3 position)
{
    // Build clip-space position from viewport coordinates
    float4 projW = mul(_ProjectionMatrix, float4(0, 0, position.z, 1));
    float4 pos4 = float4(1.0 - 2.0 * position.x, 1.0 - 2.0 * position.y, projW.z / projW.w, 1);
    float4 res4 = mul(_InvVP, pos4);
    return res4.xyz / res4.w;
}

[numthreads(32,32,1)]
void DepthToWorld(uint3 id : SV_DispatchThreadID)
{
    // Get output dimensions
    float width, height;
    _PositionRT.GetDimensions(width, height);

    // Bounds check
    if (id.x >= (uint)width || id.y >= (uint)height)
        return;

    // Calculate UV coordinates
    float2 uv = float2(float(id.x) / width, float(id.y) / height);

    // Get input depth texture dimensions
    float depthW, depthH;
    _Depth.GetDimensions(depthW, depthH);

    // Calculate sample coordinates with optional 90° CW rotation
    // ARKit depth is landscape-oriented, VFX expects portrait
    uint2 depthCoord;
    if (_RotateUV90CW != 0)
    {
        // Rotate 90° CW accounting for Y-flip: final sample = (1-v, u)
        // Since we apply Y-flip below: (x, 1-y), we need rotatedUV = (1-v, 1-u)
        float2 rotatedUV = float2(1.0 - uv.y, 1.0 - uv.x);
        depthCoord = uint2(rotatedUV.x * depthW, (1.0 - rotatedUV.y) * depthH);
    }
    else
    {
        // Standard Y-flip for ARKit texture origin
        depthCoord = uint2(uv.x * depthW, (1.0 - uv.y) * depthH);
    }
    float depth = _Depth[depthCoord];

    // Stencil filtering (human-only when enabled)
    if (_UseStencil != 0)
    {
        float stencilW, stencilH;
        _Stencil.GetDimensions(stencilW, stencilH);

        // Apply same rotation as depth
        uint2 stencilCoord;
        if (_RotateUV90CW != 0)
        {
            float2 rotatedUV = float2(1.0 - uv.y, 1.0 - uv.x);
            stencilCoord = uint2(rotatedUV.x * stencilW, (1.0 - rotatedUV.y) * stencilH);
        }
        else
        {
            stencilCoord = uint2(uv.x * stencilW, (1.0 - uv.y) * stencilH);
        }
        float stencil = _Stencil[stencilCoord];

        float stencilThreshold = _DepthRange.z > 0 ? _DepthRange.z : 0.5;
        if (stencil < stencilThreshold)
        {
            _PositionRT[id.xy] = float4(0, -1000, 0, 0);
            return;
        }
    }

    // Depth range check
    float minDepth = _DepthRange.x;
    float maxDepth = _DepthRange.y;
    if (depth < minDepth || depth > maxDepth || depth <= 0)
    {
        _PositionRT[id.xy] = float4(0, -1000, 0, 0);
        return;
    }

    // Convert to world position using ORIGINAL UV (not flipped)
    // This matches GeneratePositionTexture.compute exactly
    float3 viewportPos = float3(uv.x, uv.y, depth);
    float3 worldPos = ViewportToWorldPoint(viewportPos);

    // Write position with depth in alpha
    _PositionRT[id.xy] = float4(worldPos, 1.0);
}

// Calculate velocity from frame-to-frame position changes
[numthreads(32,32,1)]
void CalculateVelocity(uint3 id : SV_DispatchThreadID)
{
    // Get output dimensions
    float outWidth, outHeight;
    _VelocityRT.GetDimensions(outWidth, outHeight);

    // Bounds check
    if (id.x >= (uint)outWidth || id.y >= (uint)outHeight)
        return;

    // Get current and previous positions
    float4 currentPos = _PositionRT[id.xy];
    float4 previousPos = _PreviousPositionRT[id.xy];

    float3 velocity = float3(0, 0, 0);

    // Calculate velocity only if both positions are valid (w > 0)
    if (currentPos.w > 0 && previousPos.w > 0 && _DeltaTime > 0.001)
    {
        velocity = (currentPos.xyz - previousPos.xyz) / _DeltaTime;

        // Clamp velocity to reasonable values (±10 m/s)
        velocity = clamp(velocity, -10.0, 10.0);
    }

    // Write velocity (xyz) and speed magnitude (w)
    _VelocityRT[id.xy] = float4(velocity, length(velocity));
}
